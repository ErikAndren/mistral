

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Mistral documentation 1.0 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="#" class="icon icon-home" alt="Documentation Home"> Mistral documentation
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
            
              <!-- Local TOC -->
              <div class="local-toc"><ul>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cyclonev_fpga">The Cyclone V FPGA</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#the-fpgas">The FPGAs</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bitstream-stucture">Bitstream stucture</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#logic-blocks">Logic blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#routing-network">Routing network</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#programmable-inverters">Programmable inverters</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cyclonev_details">CycloneV internals description</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#routing-network">Routing network</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inner-logic-blocks">Inner logic blocks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#lab">LAB</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#mlab">MLAB</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dsp">DSP</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#m10k">M10K</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="index.html#peripheral-logic-blocks">Peripheral logic blocks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="index.html#gpio">GPIO</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dqs16">DQS16</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#fpll">FPLL</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#cmux">CMUX</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#ctrl">CTRL</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hssi">HSSI</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hip">HIP</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#dll">DLL</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#serpar">SERPAR</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#lvl">LVL</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#term">TERM</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#pma3">PMA3</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hmc">HMC</a></li>
<li class="toctree-l3"><a class="reference internal" href="index.html#hps">HPS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-boot">HPS_BOOT</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-clocks">HPS_CLOCKS</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-clocks-resets">HPS_CLOCKS_RESETS</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-cross-trigger">HPS_CROSS_TRIGGER</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-dbg-apb">HPS_DBG_APB</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-dma">HPS_DMA</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-fpga2hps">HPS_FPGA2HPS</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-fpga2sdram">HPS_FPGA2SDRAM</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-hps2fpga">HPS_HPS2FPGA</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-hps2fpga-light-weight">HPS_HPS2FPGA_LIGHT_WEIGHT</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-interrupts">HPS_INTERRUPTS</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-jtag">HPS_JTAG</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-loan-io">HPS_LOAN_IO</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-mpu-event-standby">HPS_MPU_EVENT_STANDBY</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-mpu-general-purpose">HPS_MPU_GENERAL_PURPOSE</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-can">HPS_PERIPHERAL_CAN</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-emac">HPS_PERIPHERAL_EMAC</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-i2c">HPS_PERIPHERAL_I2C</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-nand">HPS_PERIPHERAL_NAND</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-qspi">HPS_PERIPHERAL_QSPI</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-sdmmc">HPS_PERIPHERAL_SDMMC</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-spi-master">HPS_PERIPHERAL_SPI_MASTER</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-spi-slave">HPS_PERIPHERAL_SPI_SLAVE</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-uart">HPS_PERIPHERAL_UART</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-peripheral-usb">HPS_PERIPHERAL_USB</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-stm-event">HPS_STM_EVENT</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-test">HPS_TEST</a></li>
<li class="toctree-l4"><a class="reference internal" href="index.html#hps-tpiu-trace">HPS_TPIU_TRACE</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cyclonev_library_use">CycloneV library usage</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#library-structure">Library structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#packages">Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#model-information">Model information</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pos-rnode-and-pnode">pos, rnode and pnode</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#routing-network-management">Routing network management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#logic-block-management">Logic block management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inverters-management">Inverters management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#pin-package-management">Pin/package management</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#options">Options</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bitstream-management">Bitstream management</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cyclonev_driver">The mistral-cv command-line program</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#models">models</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#routes">routes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#routes2">routes2</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#cycle">cycle</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#bels">bels</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#decomp">decomp</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#comp">comp</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#diff">diff</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="index.html#document-cyclonev_library_internals">Mistral CycloneV library internals</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#structure">Structure</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#routing-data">Routing data</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#block-muxes">Block muxes</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#logic-blocks">Logic blocks</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#inverters">Inverters</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#forced-1-bits">Forced-1 bits</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#packages">Packages</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#models">Models</a></li>
</ul>
</li>
</ul>
</div>
            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="#">Mistral documentation</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="#" class="icon icon-home"></a> &raquo;</li>
        
      <li>Mistral documentation 1.0 documentation</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="mistral-a-cyclone-v-fpga-bitstream-library">
<h1>Mistral - a Cyclone V FPGA bitstream library<a class="headerlink" href="#mistral-a-cyclone-v-fpga-bitstream-library" title="Permalink to this headline">¶</a></h1>
<div class="toctree-wrapper compound">
<span id="document-cyclonev_fpga"></span><div class="section" id="the-cyclone-v-fpga">
<h2>The Cyclone V FPGA<a class="headerlink" href="#the-cyclone-v-fpga" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-fpgas">
<h3>The FPGAs<a class="headerlink" href="#the-fpgas" title="Permalink to this headline">¶</a></h3>
<p>The Cyclone V is a series of FPGAs produced initially by Altera, now
Intel.  It is based on a series of seven dies with varying levels of
capability, which is then derived into more than 400 SKUs with
variations in speed, temperature range, and enabled internal hardware.</p>
<p>As pretty much every FPGA out there, the dies are organized in grids.</p>
<div class="figure align-default" id="id1">
<a class="reference internal image-reference" href="_images/floorplans.svg"><img alt="_images/floorplans.svg" src="_images/floorplans.svg" width="100%" /></a>
<p class="caption"><span class="caption-text">Floor plan of the seven die types</span><a class="headerlink" href="#id1" title="Permalink to this image">¶</a></p>
</div>
<p>The FPGA, structurally, is a set of logic blocks of different types
communicating with each other either through direct links or through a
large routing network that spans the whole grid.</p>
<p>Some of the logic blocks take visible floor space.  Specifically, the
notches on the left are the space taken by the high speed serial
interfaces (hssi and pma3).  Also, the top-right corner in the sx50f
and sx120f variants is used to fit the hps, a dual-core arm.</p>
</div>
<div class="section" id="bitstream-stucture">
<h3>Bitstream stucture<a class="headerlink" href="#bitstream-stucture" title="Permalink to this headline">¶</a></h3>
<p>The bitstream is built from three rams:</p>
<ul class="simple">
<li><p>Option ram</p></li>
<li><p>Peripheral ram</p></li>
<li><p>Configuration ram</p></li>
</ul>
<p>The option ram is composed of 32 blocks of 40 bits, of which only 12
are actually used.  It includes the global configurations for the
chip, such as the jtag user id, the programming voltage, the internal
oscillator configuration, etc.</p>
<p>The peripheral ram stores the configuration of all the blocks situated
on the borders of the chip, e.g. everything outside of labs, mlabs,
dsps and m10ks.  It is built of 13 to 16 blocks of bits that are sent
through shift registers to the tiles.</p>
<p>The configuration ram stores the configuration of the labs, mlabs,
dsps and m10ks, plus all the routing configuration.  It also includes
the programmable inverters which allows inverting essentially all the
inputs to the peripheral blocks.  It is organised as a rectangle of
bits.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 21%" />
<col style="width: 24%" />
<col style="width: 21%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Die</p></th>
<th class="head"><p>Tiles</p></th>
<th class="head"><p>Pram</p></th>
<th class="head"><p>Cram</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>e50f</p></td>
<td><p>55x46</p></td>
<td><p>51101</p></td>
<td><p>4958x3928</p></td>
</tr>
<tr class="row-odd"><td><p>gx25f</p></td>
<td><p>49x40</p></td>
<td><p>54083</p></td>
<td><p>3856x3412</p></td>
</tr>
<tr class="row-even"><td><p>gt75f</p></td>
<td><p>69x62</p></td>
<td><p>90162</p></td>
<td><p>6006x5304</p></td>
</tr>
<tr class="row-odd"><td><p>gt150f</p></td>
<td><p>90x82</p></td>
<td><p>113922</p></td>
<td><p>7605x7024</p></td>
</tr>
<tr class="row-even"><td><p>gt300f</p></td>
<td><p>122x116</p></td>
<td><p>130828</p></td>
<td><p>10038x9948</p></td>
</tr>
<tr class="row-odd"><td><p>sx50f</p></td>
<td><p>69x62</p></td>
<td><p>80505</p></td>
<td><p>6006x5304</p></td>
</tr>
<tr class="row-even"><td><p>sx120f</p></td>
<td><p>90x82</p></td>
<td><p>99574</p></td>
<td><p>7605x7024</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="logic-blocks">
<h3>Logic blocks<a class="headerlink" href="#logic-blocks" title="Permalink to this headline">¶</a></h3>
<p>The logic blocks are of two categories, the inner blocks and the
peripheral blocks.  To a first approximation all the inner blocks are
configured through configuration ram, and the peripheral blocks
through the peripheral ram.  It only matters where it comes to partial
reconfiguration, because only the configuration ram can be dynamically
modified.  We do not yet support it though.</p>
<p>The inner blocks are:</p>
<ul class="simple">
<li><p>lab: a logic blocks group with 20 LUTs with 5 inputs and 40 Flip-Flops.</p></li>
<li><p>mlab: a lab that can be reconfigured as 64*20 bits of ram</p></li>
<li><p>dsp: a flexible multiply-add block</p></li>
<li><p>m10k: a block of 10240 bits of dual-ported memory</p></li>
</ul>
<p>The peripheral blocks are:</p>
<ul class="simple">
<li><p>gpio: general-purpose i/o, a block that controls up to 4 package pins</p></li>
<li><p>dqs16: a block that manage differential input/output for 4 gpio blocks, e.g. up to 16 pins</p></li>
<li><p>fpll: a fractional PLL</p></li>
<li><p>cmux: the clock muxes that drive the clock part of the routing network</p></li>
<li><p>ctrl: the control block with things like jtag</p></li>
<li><p>hssi: the high speed serial interfaces</p></li>
<li><p>hip: the pcie interfaces</p></li>
<li><p>cbuf: a clock buffer for the dqs16</p></li>
<li><p>dll: a delay-locked loop for the dqs16</p></li>
<li><p>serpar: TODO</p></li>
<li><p>lvl: TODO</p></li>
<li><p>term: termination control blocks</p></li>
<li><p>pma3: manages the channels of the hssi</p></li>
<li><p>hmc: hardware memory controller, a block managing sdr/ddr ram interfaces</p></li>
<li><p>hps: a series of 37 blocks managing the interface with the integrated dual-core arm</p></li>
</ul>
<p>All of these blocks are configured similarly, through the setup of
block muxes.  They can be of 4 types:
* Boolean
* Symbolic, where the choice is between alphanumeric states
* Numeric, where the choice is between a fixed set of numeric value
* Ram, where a series of bits can be set to any value</p>
<p>Configuring that part of the FPGA consists of configuring the muxes
associated to each block.</p>
</div>
<div class="section" id="routing-network">
<h3>Routing network<a class="headerlink" href="#routing-network" title="Permalink to this headline">¶</a></h3>
<p>A massive routing network is present all over the FPGA.  It has two
almost-disjoint parts.  The data network has a series of inputs,
connected to the outputs of all the blocks, and a series of outputs
that go to data inputs of the blocks.  The clock network consists of
16 global clocks signals that cover the whole FPGA, up to 88 regional
clocks that cover an half of the FPGA, and when an hssi is present a
series of horizontal peripheral clocks that are driven by the serial
communications.  Global and regional clock signals are driven by
dedicated cmux blocks (not the fpll in particular, but they do have
dedicated connections to the cmuxes).</p>
<p>These two networks join on data/clock muxes, which allow peripheral
blocks to select for their clock-like inputs which network the signal
should come from.</p>
</div>
<div class="section" id="programmable-inverters">
<h3>Programmable inverters<a class="headerlink" href="#programmable-inverters" title="Permalink to this headline">¶</a></h3>
<p>Essentially every output of the routing network that enters a
peripheral block can optionally be inverted by activating the
associated configuration bit.</p>
</div>
</div>
<span id="document-cyclonev_details"></span><div class="section" id="cyclonev-internals-description">
<h2>CycloneV internals description<a class="headerlink" href="#cyclonev-internals-description" title="Permalink to this headline">¶</a></h2>
<div class="section" id="routing-network">
<h3>Routing network<a class="headerlink" href="#routing-network" title="Permalink to this headline">¶</a></h3>
<p>The routing network follows a single-driver structure: a number of
inputs are grouped together in one place, one is selected through the
configuration, then it is amplified and used to drive a metal line.
There is also usually one bit configuration to disable the driver,
which can be all-off (probably leaving the line floating) or a
specific combination to select vcc.  The drivers correspond to a 2d
pattern in the configuration ram.  There are 70 different patterns,
configured by 1 to 18 bits and mixing 1 to 44 inputs.</p>
<p>The network itself can be split in two parts: the data network and the
clock network.</p>
<p>The data network is a grid of connections.  Horizontal lines (H14, H6
and H3, numbered by the number of tiles they span) and vertical lines
(V12, V4 and V2) helped by wire muxes (WM) connect to each over to
ensure routing over the whole surface.  Then at the tile level
tile-data dispatch (TD) nodes allow to select between the available
signals.</p>
<p>Generic output (GOUT) nodes then select between TD nodes to connect to
logic blocks inputs.  Logic block outputs go to Generic Input (GIN)
nodes which feed in the connections.  In addition a dedicated network,
the Loopback dispatch (LD) connects some of the outputs from the
labs/mlabs to their inputs for fast local data routing.</p>
<p>The clock network is more of a top-down structure.  The top structures
are Global clocks (GCLK), Regional clocks (RCLK) and Peripheral clocks
(PCLK).  They’re all driven by specialized logic blocks we call Clock
Muxes (cmux).  There are two horizontal cmux in the middle of the top
and bottom borders, each driving 4 GCLK and 20 RCLK, two vertical in
the middle of the left and right borders each driving 4 GCLK and 12
RCLK, and 3 to 4 in the corners driving 6 RCLK each.  The dies
including an HPS (sx50f and sx120f) are missing the top-right cmux
plus some of the middle-of-border-driven RCLK.  That gives a total of
16 GCLK and 66 to 88 RCLK.  In addition PCLK start from HSSI blocks to
distribute serial clocks to the network.</p>
<p>The GCLK span the whole grid.  A RCLK spans half the grid.  A PCLK
spans a number of tiles horizontally to its right.</p>
<p>The second level is Sector clocks, SCLK, which spans small rectangular
zones of tiles and connect from GCLK, RCLK and PCLK.  The on the third
level, connecting from SCLK, is Horizontal clocks (HCLK) spanning
10-15 horizontal tiles and Border clocks (BCLK) rooted regularly on
the top and bottom borders.  Finally Tile clocks (TCLK) connect from
HCLK and BCLK and distribute the clocks within a tile.</p>
<p>In addition the PMUX nodes at the entrance of plls select between
SCLKs, and the GCLKFB and RCLKFB bring back feedback signals from the
cmux to the pll.</p>
<p>Inner blocks directly connect to TCLK and have internal muxes to
select between clock and data inputs for their control.  Peripheral
blocks tend to use a secondary structure composed from a TDMUX that
selects one TD between multiple ones followed by a DCMUX that selects
between the TDMUX and a TCLK so that their clock-like inputs can be
driven from either a clock or a data signal.</p>
<p>Most GOUT and DCMUX connected to inputs to peripheral blocks are also
provided with an optional inverter.</p>
</div>
<div class="section" id="inner-logic-blocks">
<h3>Inner logic blocks<a class="headerlink" href="#inner-logic-blocks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="lab">
<h4>LAB<a class="headerlink" href="#lab" title="Permalink to this headline">¶</a></h4>
<p>The LABs are the main combinatorial and register blocks of the FPGA.
A LAB tile includes 10 sub-blocks with 64 bits of LUT splitted in 6
parts, four Flip-Flops, two 1-bit adders and a lot of routing logic.
In addition a common control subblock selects and dispatches clock,
enable, clear, etc signals.</p>
</div>
<div class="section" id="mlab">
<h4>MLAB<a class="headerlink" href="#mlab" title="Permalink to this headline">¶</a></h4>
<p>A MLAB is a lab that can optionally be turned into a 640-bits RAM or
ROM.  The wiring is identical to the LAB, only some additional muxes
are provided to select the RAM/ROM mode.</p>
<p>TODO: address/data wiring in RAM/ROM mode.</p>
</div>
<div class="section" id="dsp">
<h4>DSP<a class="headerlink" href="#dsp" title="Permalink to this headline">¶</a></h4>
<p>The DSP blocks provide a multiply-adder with either three 9x9, two
18x18 or one 27x27 multiply, and the 64-bits accumulator.  Its large
number of inputs and output makes it span two tiles vertically.</p>
<p>TODO: everything, GOUT/GIN/DCMUX mapping is done</p>
</div>
<div class="section" id="m10k">
<h4>M10K<a class="headerlink" href="#m10k" title="Permalink to this headline">¶</a></h4>
<p>The M10K blocks provide 10240 (256*40) bits of dual-ported rom or ram.</p>
<p>TODO: everything, GOUT/GIN/DCMUX mapping is done</p>
</div>
</div>
<div class="section" id="peripheral-logic-blocks">
<h3>Peripheral logic blocks<a class="headerlink" href="#peripheral-logic-blocks" title="Permalink to this headline">¶</a></h3>
<div class="section" id="gpio">
<h4>GPIO<a class="headerlink" href="#gpio" title="Permalink to this headline">¶</a></h4>
<p>The GPIO blocks connect the FPGA with the exterior through the package
pins.  Each block controls 4 pads, which are connected to up to 4
pins.</p>
<p>TODO: everything, GOUT/GIN/DCMUX mapping is done</p>
</div>
<div class="section" id="dqs16">
<h4>DQS16<a class="headerlink" href="#dqs16" title="Permalink to this headline">¶</a></h4>
<p>The DQS16 blocks handle differential signaling protocols.  Each
supervises 4 GPIO blocks for a total of 16 signals, hence their name.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="fpll">
<h4>FPLL<a class="headerlink" href="#fpll" title="Permalink to this headline">¶</a></h4>
<p>The Fractional PLL blocks synthesize 9 frequencies from an input with integer or fractional ratios.</p>
<p>TODO: everything, GOUT/GIN/DCMUX mapping is done</p>
</div>
<div class="section" id="cmux">
<h4>CMUX<a class="headerlink" href="#cmux" title="Permalink to this headline">¶</a></h4>
<p>The Clock mux blocks drive the GCLK and the RCLK.</p>
<p>TODO: fpll feedback lines</p>
</div>
<div class="section" id="ctrl">
<h4>CTRL<a class="headerlink" href="#ctrl" title="Permalink to this headline">¶</a></h4>
<p>The Control block gives access to a number of anciliary functions of the FPGA.</p>
<p>TODO: everything, GOUT/GIN/DCMUX mapping is done</p>
</div>
<div class="section" id="hssi">
<h4>HSSI<a class="headerlink" href="#hssi" title="Permalink to this headline">¶</a></h4>
<p>The High speed serial interface blocks control the
serializing/deserializing capabilities of the FPGA.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="hip">
<h4>HIP<a class="headerlink" href="#hip" title="Permalink to this headline">¶</a></h4>
<p>The PCIe Hard-IP blocks control the PCIe interfaces of the FPGA.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="dll">
<h4>DLL<a class="headerlink" href="#dll" title="Permalink to this headline">¶</a></h4>
<p>The Delay-Locked loop does phase control for the DQS16.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="serpar">
<h4>SERPAR<a class="headerlink" href="#serpar" title="Permalink to this headline">¶</a></h4>
<p>Unclear yet.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="lvl">
<h4>LVL<a class="headerlink" href="#lvl" title="Permalink to this headline">¶</a></h4>
<p>The Leveling Delay Chain does something linked to the DQS16.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="term">
<h4>TERM<a class="headerlink" href="#term" title="Permalink to this headline">¶</a></h4>
<p>The TERM blocks control the On-Chip Termination circuitry</p>
<p>TODO: everything</p>
</div>
<div class="section" id="pma3">
<h4>PMA3<a class="headerlink" href="#pma3" title="Permalink to this headline">¶</a></h4>
<p>The PMA3 blocks control triplets of channels used with the HSSI.</p>
<p>TODO: everything</p>
</div>
<div class="section" id="hmc">
<h4>HMC<a class="headerlink" href="#hmc" title="Permalink to this headline">¶</a></h4>
<p>The Hardware memory controller controls sets of GPIOs to implement
modern SDR and DDR memory interfaces.  In the sx dies one of them is
taken over by the HPS.  They can be bypassed in favor of direct access
to the GPIOs.</p>
<p>TODO: everything, and in particular the hmc-input -&gt; GPIO input
mapping when bypassed.</p>
</div>
<div class="section" id="hps">
<h4>HPS<a class="headerlink" href="#hps" title="Permalink to this headline">¶</a></h4>
<p>The interface between the FPGA and the Hard processor system is done
through 37 specialized blocks or 28 different types.</p>
<p>TODO: everything.  GOUT/GIN/DCMUX mapping is done except for HPS_CLOCKS.</p>
<div class="section" id="hps-boot">
<h5>HPS_BOOT<a class="headerlink" href="#hps-boot" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-clocks">
<h5>HPS_CLOCKS<a class="headerlink" href="#hps-clocks" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-clocks-resets">
<h5>HPS_CLOCKS_RESETS<a class="headerlink" href="#hps-clocks-resets" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-cross-trigger">
<h5>HPS_CROSS_TRIGGER<a class="headerlink" href="#hps-cross-trigger" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-dbg-apb">
<h5>HPS_DBG_APB<a class="headerlink" href="#hps-dbg-apb" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-dma">
<h5>HPS_DMA<a class="headerlink" href="#hps-dma" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-fpga2hps">
<h5>HPS_FPGA2HPS<a class="headerlink" href="#hps-fpga2hps" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-fpga2sdram">
<h5>HPS_FPGA2SDRAM<a class="headerlink" href="#hps-fpga2sdram" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-hps2fpga">
<h5>HPS_HPS2FPGA<a class="headerlink" href="#hps-hps2fpga" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-hps2fpga-light-weight">
<h5>HPS_HPS2FPGA_LIGHT_WEIGHT<a class="headerlink" href="#hps-hps2fpga-light-weight" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-interrupts">
<h5>HPS_INTERRUPTS<a class="headerlink" href="#hps-interrupts" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-jtag">
<h5>HPS_JTAG<a class="headerlink" href="#hps-jtag" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-loan-io">
<h5>HPS_LOAN_IO<a class="headerlink" href="#hps-loan-io" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-mpu-event-standby">
<h5>HPS_MPU_EVENT_STANDBY<a class="headerlink" href="#hps-mpu-event-standby" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-mpu-general-purpose">
<h5>HPS_MPU_GENERAL_PURPOSE<a class="headerlink" href="#hps-mpu-general-purpose" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-peripheral-can">
<h5>HPS_PERIPHERAL_CAN<a class="headerlink" href="#hps-peripheral-can" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-peripheral-emac">
<h5>HPS_PERIPHERAL_EMAC<a class="headerlink" href="#hps-peripheral-emac" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-peripheral-i2c">
<h5>HPS_PERIPHERAL_I2C<a class="headerlink" href="#hps-peripheral-i2c" title="Permalink to this headline">¶</a></h5>
<p>(4 blocks)</p>
</div>
<div class="section" id="hps-peripheral-nand">
<h5>HPS_PERIPHERAL_NAND<a class="headerlink" href="#hps-peripheral-nand" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-peripheral-qspi">
<h5>HPS_PERIPHERAL_QSPI<a class="headerlink" href="#hps-peripheral-qspi" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-peripheral-sdmmc">
<h5>HPS_PERIPHERAL_SDMMC<a class="headerlink" href="#hps-peripheral-sdmmc" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-peripheral-spi-master">
<h5>HPS_PERIPHERAL_SPI_MASTER<a class="headerlink" href="#hps-peripheral-spi-master" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-peripheral-spi-slave">
<h5>HPS_PERIPHERAL_SPI_SLAVE<a class="headerlink" href="#hps-peripheral-spi-slave" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-peripheral-uart">
<h5>HPS_PERIPHERAL_UART<a class="headerlink" href="#hps-peripheral-uart" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-peripheral-usb">
<h5>HPS_PERIPHERAL_USB<a class="headerlink" href="#hps-peripheral-usb" title="Permalink to this headline">¶</a></h5>
<p>(2 blocks)</p>
</div>
<div class="section" id="hps-stm-event">
<h5>HPS_STM_EVENT<a class="headerlink" href="#hps-stm-event" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-test">
<h5>HPS_TEST<a class="headerlink" href="#hps-test" title="Permalink to this headline">¶</a></h5>
</div>
<div class="section" id="hps-tpiu-trace">
<h5>HPS_TPIU_TRACE<a class="headerlink" href="#hps-tpiu-trace" title="Permalink to this headline">¶</a></h5>
</div>
</div>
</div>
</div>
<span id="document-cyclonev_library_use"></span><div class="section" id="cyclonev-library-usage">
<h2>CycloneV library usage<a class="headerlink" href="#cyclonev-library-usage" title="Permalink to this headline">¶</a></h2>
<div class="section" id="library-structure">
<h3>Library structure<a class="headerlink" href="#library-structure" title="Permalink to this headline">¶</a></h3>
<p>The library provides a CycloneV class in the mistral namespace.
Information is provided to allow to choose a CycloneV::Model object
which represents a sold FPGA variant.  Then a CycloneV object can be
created from it.  That object stores the state of the FPGA
configuration and allows to read and modify it.</p>
<p>All the types, enums, functions, methods, arrays etc described in the
following paragraph are in the CycloneV class.</p>
</div>
<div class="section" id="packages">
<h3>Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">package_type_t</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">CycloneV</span><span class="o">::</span><span class="n">package_info_t</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">pin_count</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">width_in_pins</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height_in_pins</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">width_in_mm</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">height_in_mm</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">package_info_t</span> <span class="n">package_infos</span><span class="p">[</span><span class="mi">5</span><span class="o">+</span><span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="p">];</span>
</pre></div>
</div>
<p>The FPGAs are sold in 11 different packages, which are named by their
type (Fineline BGA, Ultra Fineline BGA or Micro Fineline BGA) and
their width in mm.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 19%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 26%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Enum</p></th>
<th class="head"><p>Type</p></th>
<th class="head"><p>Pins</p></th>
<th class="head"><p>Size in mm</p></th>
<th class="head"><p>Size in pins</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>PKG_F17</p></td>
<td><p>f</p></td>
<td><p>256</p></td>
<td><p>16x16</p></td>
<td><p>17x17</p></td>
</tr>
<tr class="row-odd"><td><p>PKG_F23</p></td>
<td><p>f</p></td>
<td><p>484</p></td>
<td><p>22x22</p></td>
<td><p>23x23</p></td>
</tr>
<tr class="row-even"><td><p>PKG_F27</p></td>
<td><p>f</p></td>
<td><p>672</p></td>
<td><p>26x26</p></td>
<td><p>27x27</p></td>
</tr>
<tr class="row-odd"><td><p>PKG_F31</p></td>
<td><p>f</p></td>
<td><p>896</p></td>
<td><p>30x30</p></td>
<td><p>31x31</p></td>
</tr>
<tr class="row-even"><td><p>PKG_F35</p></td>
<td><p>f</p></td>
<td><p>1152</p></td>
<td><p>34x34</p></td>
<td><p>35x35</p></td>
</tr>
<tr class="row-odd"><td><p>PKG_U15</p></td>
<td><p>u</p></td>
<td><p>324</p></td>
<td><p>18x18</p></td>
<td><p>15x15</p></td>
</tr>
<tr class="row-even"><td><p>PKG_U19</p></td>
<td><p>u</p></td>
<td><p>484</p></td>
<td><p>22x22</p></td>
<td><p>19x19</p></td>
</tr>
<tr class="row-odd"><td><p>PKG_U23</p></td>
<td><p>u</p></td>
<td><p>672</p></td>
<td><p>28x28</p></td>
<td><p>23x23</p></td>
</tr>
<tr class="row-even"><td><p>PKG_M11</p></td>
<td><p>m</p></td>
<td><p>301</p></td>
<td><p>21x21</p></td>
<td><p>11x11</p></td>
</tr>
<tr class="row-odd"><td><p>PKG_M13</p></td>
<td><p>m</p></td>
<td><p>383</p></td>
<td><p>25x25</p></td>
<td><p>13x13</p></td>
</tr>
<tr class="row-even"><td><p>PKG_M15</p></td>
<td><p>m</p></td>
<td><p>484</p></td>
<td><p>28x28</p></td>
<td><p>15x15</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="model-information">
<h3>Model information<a class="headerlink" href="#model-information" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">die_type_t</span> <span class="p">{</span> <span class="n">E50F</span><span class="p">,</span> <span class="n">GX25F</span><span class="p">,</span> <span class="n">GT75F</span><span class="p">,</span> <span class="n">GT150F</span><span class="p">,</span> <span class="n">GT300F</span><span class="p">,</span> <span class="n">SX50F</span><span class="p">,</span> <span class="n">SX120F</span> <span class="p">};</span>

<span class="k">struct</span> <span class="nc">Model</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">variant_info</span> <span class="o">&amp;</span><span class="n">variant</span><span class="p">;</span>
  <span class="n">package_type_t</span> <span class="n">package</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">temperature</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">speed</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">pcie</span><span class="p">,</span> <span class="n">gxb</span><span class="p">,</span> <span class="n">hmc</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">io</span><span class="p">,</span> <span class="n">gpio</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">variant_info</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">die_info</span> <span class="o">&amp;</span><span class="n">die</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">idcode</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">alut</span><span class="p">,</span> <span class="n">alm</span><span class="p">,</span> <span class="n">memory</span><span class="p">,</span> <span class="n">dsp</span><span class="p">,</span> <span class="n">dpll</span><span class="p">,</span> <span class="n">dll</span><span class="p">,</span> <span class="n">hps</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">die_info</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="n">die_type_t</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">tile_sx</span><span class="p">,</span> <span class="n">tile_sy</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">Model</span> <span class="n">models</span><span class="p">[];</span>
<span class="n">CycloneV</span> <span class="o">*</span><span class="nf">get_model</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">model_name</span><span class="p">);</span>
</pre></div>
</div>
<p>A Model is built from a package, a variant and a temperature/speed
grade.  A variant selects a die and which hardware is active on it.</p>
<p>The Model fields are:</p>
<ul class="simple">
<li><p>name - the SKU, for instance 5CSEBA6U23I7</p></li>
<li><p>variant - its associated variant_info</p></li>
<li><p>package - the packaging used</p></li>
<li><p>temperature - the temperature grade, ‘A’ for automotive (-45..125C), ‘I’ for industrial (-40..100C), ‘C’ for commercial (0..85C)</p></li>
<li><p>speed - the speed grade, 6-8, smaller is faster</p></li>
<li><p>pcie - number of PCIe interfaces (depends on both variant and number of available pins)</p></li>
<li><p>gxb - ??? (same)</p></li>
<li><p>hmc - number of Memory interfaces (same)</p></li>
<li><p>io - number of i/os</p></li>
<li><p>gpio - number of fpga-usable gpios</p></li>
</ul>
<p>The Variant fields are:</p>
<ul class="simple">
<li><p>name - name of the variant, for instance se120b</p></li>
<li><p>die - its associated die_info</p></li>
<li><p>idcode - the IDCODE associated to this variant (not unique per variant at all)</p></li>
<li><p>alut - number of LUTs</p></li>
<li><p>alm - number of logic elements</p></li>
<li><p>memory - bits of memory</p></li>
<li><p>dsp - number of dsp blocks</p></li>
<li><p>dpll - number of plls</p></li>
<li><p>dll - number of delay-locked loops</p></li>
<li><p>hps - number of arm cores</p></li>
</ul>
<p>The Die usable fields are:</p>
<ul class="simple">
<li><p>name - name of the die, for instance sx120f</p></li>
<li><p>type - the enum value for the die type</p></li>
<li><p>tile_sx, tile_sy - size of the tile grid</p></li>
</ul>
<p>The limits indicated in the variant structure may be lower than the
theoretical die capabilities.  We have no idea what happens if these
limits are not respected.</p>
<p>To create a CycloneV object, the constructor requires a Model *.
Either choose one from the models array, or, in the usual case of
selection by sku, the CycloneV::get_model function looks it up and
allocates one.  The models array ends with a nullptr name pointer.</p>
<p>The get_model function implements the alias “ms” for the 5CSEBA6U23I7
used in the de10-nano, a.k.a MiSTer.</p>
</div>
<div class="section" id="pos-rnode-and-pnode">
<h3>pos, rnode and pnode<a class="headerlink" href="#pos-rnode-and-pnode" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pos_t</span> <span class="o">=</span> <span class="kt">uint16_t</span><span class="p">;</span>          <span class="c1">// Tile position</span>

<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">uint32_t</span> <span class="n">pos2x</span><span class="p">(</span><span class="n">pos_t</span> <span class="n">xy</span><span class="p">);</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">uint32_t</span> <span class="n">pos2y</span><span class="p">(</span><span class="n">pos_t</span> <span class="n">xy</span><span class="p">);</span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="n">pos_t</span> <span class="n">xy2pos</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">y</span><span class="p">);</span>
</pre></div>
</div>
<p>The type pos_t represents a position in the grid.  xy2pos allows to create one, pos2x and pos2y extracts the coordinates.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">rnode_t</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>        <span class="c1">// Route node id</span>

<span class="k">enum</span> <span class="nc">rnode_type_t</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">rnode_type_names</span><span class="p">[];</span>
<span class="n">rnode_type_t</span> <span class="nf">rnode_type_lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="n">rnode_t</span> <span class="n">rnode</span><span class="p">(</span><span class="n">rnode_type_t</span> <span class="n">type</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">z</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">rnode_t</span> <span class="n">rnode</span><span class="p">(</span><span class="n">rnode_type_t</span> <span class="n">type</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">y</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">z</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">rnode_type_t</span> <span class="n">rn2t</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">pos_t</span> <span class="n">rn2p</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">uint32_t</span> <span class="n">rn2x</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">uint32_t</span> <span class="n">rn2y</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">uint32_t</span> <span class="n">rn2z</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">rn2s</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">);</span>
</pre></div>
</div>
<p>A rnode_t represents a note in the routing network.  It is
characterized by its type (rnode_type_t) and its coordinates (x, y for
the tile, z for the instance number in the tile).  Those functions
allow to create one and extract the different components.
rnode_types_names gives the string representation for every
rnode_type_t value, and rnode_type_lookup finds the rnode_type_t for a
given name.  rn2s provides a string representation of the rnode
(TYPE.xxx.yyy.zzzz).</p>
<p>The rnode_type_t value 0 is NONE, and a rnode_t of 0 is guaranteed
invalid.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">pnode_t</span> <span class="o">=</span> <span class="kt">uint64_t</span><span class="p">;</span>        <span class="c1">// Port node id</span>

<span class="k">enum</span> <span class="nc">block_type_t</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">block_type_names</span><span class="p">[];</span>
<span class="n">block_type_t</span> <span class="nf">block_type_lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">enum</span> <span class="nc">port_type_t</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">port_type_names</span><span class="p">[];</span>
<span class="n">port_type_t</span>  <span class="nf">port_type_lookup</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">constexpr</span> <span class="n">pnode_t</span> <span class="n">pnode</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">bt</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">port_type_t</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">bindex</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">pindex</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">pnode_t</span> <span class="n">pnode</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">bt</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">x</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">y</span><span class="p">,</span> <span class="n">port_type_t</span> <span class="n">pt</span><span class="p">,</span> <span class="kt">int8_t</span> <span class="n">bindex</span><span class="p">,</span> <span class="kt">int16_t</span> <span class="n">pindex</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">block_type_t</span> <span class="n">pn2bt</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">port_type_t</span>  <span class="n">pn2pt</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="n">pos_t</span>        <span class="n">pn2p</span> <span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">uint32_t</span>     <span class="n">pn2x</span> <span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">uint32_t</span>     <span class="n">pn2y</span> <span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">int8_t</span>       <span class="n">pn2bi</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
<span class="k">constexpr</span> <span class="kt">int16_t</span>      <span class="n">pn2pi</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">pn2s</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">);</span>
</pre></div>
</div>
<p>A pnode_t represents a port of a logical block.  It is characterized
by the block type (block_type_t), the block tile position, the block
number instance (when appropriate, -1 when not), the port type
(port_type_t) and the bit number in the port (when appropriate, -1
when not).  pn2s provides the string representation
BLOCK.xxx.yyy(.instance):PORT(.bit)</p>
<p>The block_type_t value 0 is BNONE, the port_type_t value 0 is PNONE,
and pnode_t 0 is guaranteed invalid.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">rnode_t</span> <span class="nf">pnode_to_rnode</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">pn</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">pnode_t</span> <span class="nf">rnode_to_pnode</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">rn</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>These two methods allow to find the connections between the logic
block ports and the routing nodes.  It is always 1:1 when there is
one.</p>
</div>
<div class="section" id="routing-network-management">
<h3>Routing network management<a class="headerlink" href="#routing-network-management" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">rnode_link</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">n1</span><span class="p">,</span> <span class="n">rnode_t</span> <span class="n">n2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rnode_link</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">rnode_t</span> <span class="n">n2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rnode_link</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">n1</span><span class="p">,</span> <span class="n">pnode_t</span> <span class="n">p2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rnode_link</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">p1</span><span class="p">,</span> <span class="n">pnode_t</span> <span class="n">p2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rnode_unlink</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">n2</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rnode_unlink</span><span class="p">(</span><span class="n">pnode_t</span> <span class="n">p2</span><span class="p">);</span>
</pre></div>
</div>
<p>The method rnode_link links two nodes together with n1 as source and
n2 as destination, automatically converting from pnode_t to rnode_t
when needed.  rnode_unlink disconnects anything connected to the
destination n2.</p>
<p>There are two special cases.  DCMUX is a 2:1 mux which selects between
a data and a clock signal and has no disconnected state.  Unlinking it
puts in in the default clock position.  Most SCLK muxes use a 5-bit
vertical configuration where up to 5 inputs can be connected and the
all-off configuration is not allowed.  Usually at least one input goes
to vcc, but in some cases all five are used and unlinking selects the
4th input (the default in that case).</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">rnode_t</span><span class="p">,</span> <span class="n">rnode_t</span><span class="o">&gt;&gt;</span> <span class="n">route_all_active_links</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">rnode_t</span><span class="p">,</span> <span class="n">rnode_t</span><span class="o">&gt;&gt;</span> <span class="n">route_frontier_links</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>route_all_active_links gives all current active connections.
route_frontier_links solves these connections to keep only the
extremities, giving the inter-logic-block connections directly.</p>
</div>
<div class="section" id="logic-block-management">
<h3>Logic block management<a class="headerlink" href="#logic-block-management" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pos_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lab_get_pos</span><span class="p">()</span>    <span class="k">const</span>
<span class="p">[</span><span class="n">etc</span><span class="p">]</span>
</pre></div>
</div>
<p>The numerous xxx_get_pos() methods gives the list of positions of
logic blocks of a given type.  The known types are lab, mlab, m10k,
dsp, hps, gpio, dqs16, fpll, cmuxc, cmuxv, cmuxh, dll, hssi, cbuf,
lvl, ctrl, pma3, serpar, term and hip.  A vector is empty when a block
type doesn’t exist in the given die.</p>
<p>In the hps case the 37 blocks can be indexed by hps_index_t enum.</p>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="p">{</span> <span class="n">MT_MUX</span><span class="p">,</span> <span class="n">MT_NUM</span><span class="p">,</span> <span class="n">MT_BOOL</span><span class="p">,</span> <span class="n">MT_RAM</span> <span class="p">};</span>

<span class="k">enum</span> <span class="nc">bmux_type_t</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="k">const</span> <span class="n">bmux_type_names</span><span class="p">[];</span>
<span class="n">bmux_type_t</span> <span class="nf">bmux_type_lookup</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">struct</span> <span class="nc">bmux_setting_t</span> <span class="p">{</span>
  <span class="n">block_type_t</span> <span class="n">btype</span><span class="p">;</span>
  <span class="n">pos_t</span> <span class="n">pos</span><span class="p">;</span>
  <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">midx</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">def</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// bmux_type_t, or number, or bool value, or count of bits for ram</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">bmux_type</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">bmux_get</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="n">bmux_setting_t</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">bmux_set</span><span class="p">(</span><span class="k">const</span> <span class="n">bmux_setting_t</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">bmux_m_set</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">bmux_n_set</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">bmux_b_set</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">bmux_r_set</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">bmux_r_set</span><span class="p">(</span><span class="n">block_type_t</span> <span class="n">btype</span><span class="p">,</span> <span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">int</span> <span class="n">midx</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">bmux_setting_t</span><span class="o">&gt;</span> <span class="n">bmux_get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>These methods allow to manage the logic blocks muxes configurations.
A mux is characterized by its block (type and position), its type
(bmux_type_t) and its instance number (0 if there is only one).  There
are four kinds of muxes, symbolic (MT_MUX), numeric (MT_NUM), booolean
(MT_BOOL) and ram (MT_RAM).</p>
<p>bmux_type looks up a mux and returns its MT_* type, or -1 if it
doesn’t exist.  bmux_get reads the state of a mux and returns it in s
and true when found, false otherwise.  The def field indicates whether
the value is the default.  The bmux_set sets a mux generically, and
the bmux_*_set sets it per-type.</p>
<p>The no-parameter bmux_get version returns the state of all muxes of the FPGA.</p>
</div>
<div class="section" id="inverters-management">
<h3>Inverters management<a class="headerlink" href="#inverters-management" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">inv_setting_t</span> <span class="p">{</span>
  <span class="n">rnode_t</span> <span class="n">node</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">value</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">def</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">inv_setting_t</span><span class="o">&gt;</span> <span class="n">inv_get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">inv_set</span><span class="p">(</span><span class="n">rnode_t</span> <span class="n">node</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>inv_get() returns the state of the programmable inverters, and inv_set
sets the state of one.  The field def is currently very incorrect.</p>
</div>
<div class="section" id="pin-package-management">
<h3>Pin/package management<a class="headerlink" href="#pin-package-management" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="nc">pin_flags_t</span> <span class="o">:</span> <span class="kt">uint32_t</span> <span class="p">{</span>
  <span class="n">PIN_IO_MASK</span>    <span class="o">=</span> <span class="mh">0x00000007</span><span class="p">,</span>
  <span class="n">PIN_DPP</span>        <span class="o">=</span> <span class="mh">0x00000001</span><span class="p">,</span> <span class="c1">// Dedicated Programming Pin</span>
  <span class="n">PIN_HSSI</span>       <span class="o">=</span> <span class="mh">0x00000002</span><span class="p">,</span> <span class="c1">// High Speed Serial Interface input</span>
  <span class="n">PIN_JTAG</span>       <span class="o">=</span> <span class="mh">0x00000003</span><span class="p">,</span> <span class="c1">// JTAG</span>
  <span class="n">PIN_GPIO</span>       <span class="o">=</span> <span class="mh">0x00000004</span><span class="p">,</span> <span class="c1">// General-Purpose I/O</span>

  <span class="n">PIN_HPS</span>        <span class="o">=</span> <span class="mh">0x00000008</span><span class="p">,</span> <span class="c1">// Hardware Processor System</span>

  <span class="n">PIN_DIFF_MASK</span>  <span class="o">=</span> <span class="mh">0x00000070</span><span class="p">,</span>
  <span class="n">PIN_DM</span>         <span class="o">=</span> <span class="mh">0x00000010</span><span class="p">,</span>
  <span class="n">PIN_DQS</span>        <span class="o">=</span> <span class="mh">0x00000020</span><span class="p">,</span>
  <span class="n">PIN_DQS_DIS</span>    <span class="o">=</span> <span class="mh">0x00000030</span><span class="p">,</span>
  <span class="n">PIN_DQSB</span>       <span class="o">=</span> <span class="mh">0x00000040</span><span class="p">,</span>
  <span class="n">PIN_DQSB_DIS</span>   <span class="o">=</span> <span class="mh">0x00000050</span><span class="p">,</span>

  <span class="n">PIN_TYPE_MASK</span>  <span class="o">=</span> <span class="mh">0x00000f00</span><span class="p">,</span>
  <span class="n">PIN_DO_NOT_USE</span> <span class="o">=</span> <span class="mh">0x00000100</span><span class="p">,</span>
  <span class="n">PIN_GXP_RREF</span>   <span class="o">=</span> <span class="mh">0x00000200</span><span class="p">,</span>
  <span class="n">PIN_NC</span>         <span class="o">=</span> <span class="mh">0x00000300</span><span class="p">,</span>
  <span class="n">PIN_VCC</span>        <span class="o">=</span> <span class="mh">0x00000400</span><span class="p">,</span>
  <span class="n">PIN_VCCL_SENSE</span> <span class="o">=</span> <span class="mh">0x00000500</span><span class="p">,</span>
  <span class="n">PIN_VCCN</span>       <span class="o">=</span> <span class="mh">0x00000600</span><span class="p">,</span>
  <span class="n">PIN_VCCPD</span>      <span class="o">=</span> <span class="mh">0x00000700</span><span class="p">,</span>
  <span class="n">PIN_VREF</span>       <span class="o">=</span> <span class="mh">0x00000800</span><span class="p">,</span>
  <span class="n">PIN_VSS</span>        <span class="o">=</span> <span class="mh">0x00000900</span><span class="p">,</span>
  <span class="n">PIN_VSS_SENSE</span>  <span class="o">=</span> <span class="mh">0x00000a00</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">pin_info_t</span> <span class="p">{</span>
  <span class="kt">uint8_t</span> <span class="n">x</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="n">y</span><span class="p">;</span>
  <span class="kt">uint16_t</span> <span class="n">pad</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">io_block</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">length</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">delay_ps</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">const</span> <span class="n">pin_info_t</span> <span class="o">*</span><span class="n">pin_find_pos</span><span class="p">(</span><span class="n">pos_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The pin_info_t structure describes a pin with:</p>
<ul class="simple">
<li><p>x, y - its coordinates in the package grid (not the fpga grid, the pins one)</p></li>
<li><p>pad - either 0xffff (no associated gpio) or (index &lt;&lt; 14) | tile_pos, where index indicates which pad of the gpio is connected to the pin</p></li>
<li><p>flags - flags describing the pin function</p></li>
<li><p>name - pin name, like A1</p></li>
<li><p>function - pin function as text, like “GND”</p></li>
<li><p>io_block - name of the I/O block for power purposes, like 9A</p></li>
<li><p>r, c, l - electrical characteristics of the pin-pad connection wire</p></li>
<li><p>length - length of the wire</p></li>
<li><p>delay_ps - usual signal transmission delay is ps</p></li>
<li><p>index - pin sub-index for hssi_input, hssi_output, dedicated programming pins and jtag</p></li>
</ul>
<p>The pin_find_pos method looks up a pin from a gpio tile/index combination.</p>
</div>
<div class="section" id="options">
<h3>Options<a class="headerlink" href="#options" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nc">opt_setting_t</span> <span class="p">{</span>
  <span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">def</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// bmux_type_t, or number, or bool value, or count of bits for ram</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">opt_type</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">opt_get</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="n">opt_setting_t</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">opt_set</span><span class="p">(</span><span class="k">const</span> <span class="n">opt_setting_t</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">opt_m_set</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="n">bmux_type_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">opt_n_set</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">opt_b_set</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">opt_r_set</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">s</span><span class="p">);</span>
<span class="kt">bool</span> <span class="nf">opt_r_set</span><span class="p">(</span><span class="n">bmux_type_t</span> <span class="n">mux</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">s</span><span class="p">);</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">opt_setting_t</span><span class="o">&gt;</span> <span class="n">opt_get</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>The options work like the block muxes without a block, tile or
instance number.  They’re otherwise the same.</p>
</div>
<div class="section" id="bitstream-management">
<h3>Bitstream management<a class="headerlink" href="#bitstream-management" title="Permalink to this headline">¶</a></h3>
<div class="highlight-C++ notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span>
<span class="kt">void</span> <span class="nf">rbf_load</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">rbf_save</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">);</span>
</pre></div>
</div>
<p>The clear method returns the FPGA state to all defaults.  rbf_load
parses a raw bitstream file from memory and loads the state from it.
rbf_save generats a rbf from the current state.</p>
</div>
</div>
<span id="document-cyclonev_driver"></span><div class="section" id="the-mistral-cv-command-line-program">
<h2>The mistral-cv command-line program<a class="headerlink" href="#the-mistral-cv-command-line-program" title="Permalink to this headline">¶</a></h2>
<p>The mistral-cv command line program allows for a minimal interfacing
with the library.  Calling it without parameters shows the possible
usages.</p>
<div class="section" id="models">
<h3>models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">models</span>
</pre></div>
</div>
<p>Lists the known models with their SKU, IDCODE, die, variant, package,
number of pins, temperature grade and speed grade.</p>
</div>
<div class="section" id="routes">
<h3>routes<a class="headerlink" href="#routes" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">routes</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Dumps the active routes in a rbf.</p>
</div>
<div class="section" id="routes2">
<h3>routes2<a class="headerlink" href="#routes2" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">routes</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Dumps the active routes in a rbf where a GIN/GOUT/etc does not have a
port mapping associated.</p>
</div>
<div class="section" id="cycle">
<h3>cycle<a class="headerlink" href="#cycle" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">cycle</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file2</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Loads the rbf in file1.rbf and saves is back in file2.rbf.  Useful to
test if the framing/unframing of oram/pram/cram works correctly.</p>
</div>
<div class="section" id="bels">
<h3>bels<a class="headerlink" href="#bels" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">bels</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Dumps a list of all the logic elements of a model (only depends on the
die in practice).</p>
</div>
<div class="section" id="decomp">
<h3>decomp<a class="headerlink" href="#decomp" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">decomp</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">bt</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Decompiles a bitstream into a compilable source.  Only writes down
what is identified as not being in default state.</p>
</div>
<div class="section" id="comp">
<h3>comp<a class="headerlink" href="#comp" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">comp</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">bt</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Compiles a source into a bitstream.  The source includes the model
information.</p>
</div>
<div class="section" id="diff">
<h3>diff<a class="headerlink" href="#diff" title="Permalink to this headline">¶</a></h3>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">mistral</span><span class="o">-</span><span class="n">cv</span> <span class="n">diff</span> <span class="o">&lt;</span><span class="n">model</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file1</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span> <span class="o">&lt;</span><span class="n">file2</span><span class="o">.</span><span class="n">rbf</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Compares two rbf files and identifies the differences in terms of
oram, pram and cram.  Useful to list mismatches after a decomp/comp
cycle.</p>
</div>
</div>
<span id="document-cyclonev_library_internals"></span><div class="section" id="mistral-cyclonev-library-internals">
<h2>Mistral CycloneV library internals<a class="headerlink" href="#mistral-cyclonev-library-internals" title="Permalink to this headline">¶</a></h2>
<div class="section" id="structure">
<h3>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h3>
<p>A large part of the library is generated code from information in the
data directory.  The exception is the routing data that is converter
to compressed binary and put in the gdata directory.  All the
conversions are done with python programs and shell scripts in the
tools directory.</p>
</div>
<div class="section" id="routing-data">
<h3>Routing data<a class="headerlink" href="#routing-data" title="Permalink to this headline">¶</a></h3>
<p>The routing data is stored in bzip2-compressed text files named
&lt;die&gt;-r.txt.bz2.  Each line describes a routing mux.</p>
<p>A mux description looks like that:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">H14</span><span class="o">.</span><span class="mf">000.032</span><span class="o">.</span><span class="mi">0003</span> <span class="mi">4</span><span class="p">:</span><span class="mi">0024_2832</span> <span class="mi">0</span><span class="p">:</span><span class="n">GIN</span><span class="o">.</span><span class="mf">000.032</span><span class="o">.</span><span class="mi">0005</span> <span class="mi">1</span><span class="p">:</span><span class="n">GIN</span><span class="o">.</span><span class="mf">000.032</span><span class="o">.</span><span class="mi">0004</span> <span class="mi">2</span><span class="p">:</span><span class="n">GIN</span><span class="o">.</span><span class="mf">000.032</span><span class="o">.</span><span class="mi">0001</span> <span class="mi">3</span><span class="p">:</span><span class="n">GIN</span><span class="o">.</span><span class="mf">000.032</span><span class="o">.</span><span class="mi">0000</span>
</pre></div>
</div>
<p>That line describes the mux for the rnode H14.000.032.0003.  It uses
the pattern 4 as position (24, 2832) and has four inputs connected to
four GIN rnodes.</p>
<p>The chip uses a limited number of mux types, with a specific bit
pattern in the cram controlling a fixed number of inputs and of bit
set/unset values selecting them.  There is a total of 70 different
patterns, currently only described as C++ code in cv-rpats.cc.  An
additional 4 are added to store the variations of pattern 6 where the
default is different.</p>
<p>The special case of pattern 6 looks like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SCLK</span><span class="o">.</span><span class="mf">014.000</span><span class="o">.</span><span class="mi">0025</span> <span class="mf">6.3</span><span class="p">:</span><span class="mi">1413_0638</span> <span class="mi">0</span><span class="p">:</span><span class="n">GCLK</span><span class="o">.</span><span class="mf">000.008</span><span class="o">.</span><span class="mi">0009</span> <span class="mi">1</span><span class="p">:</span><span class="n">RCLK</span><span class="o">.</span><span class="mf">000.004</span><span class="o">.</span><span class="mi">0011</span> <span class="mi">4</span><span class="p">:</span><span class="n">RCLK</span><span class="o">.</span><span class="mf">000.004</span><span class="o">.</span><span class="mi">0003</span>
</pre></div>
</div>
<p>The “.3” indicates that the default is on slot 3, e.g. value 0x08 or pattern 70+3.</p>
<p>The python script routes-to-bin.py loads this file and generated a
compressed binary version in gdata which matches the rmux structure.
The script mkroutes.sh generates it for all die types.</p>
</div>
<div class="section" id="block-muxes">
<h3>Block muxes<a class="headerlink" href="#block-muxes" title="Permalink to this headline">¶</a></h3>
<p>The lists of block muxes and options muxes are independant of the
dies.  They’re in the block-mux.txt files.  Each mux is described in
these files using the following syntax:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>g dft_mode m:3 21.42 20.40 20.43
  0 off
  1 on !
  7 dft_pprog
</pre></div>
</div>
<p>“g” indicates the subtype of mux, which is block-dependant, here
“global”.  ‘m’ indicates a symbolic mux, 3 is the number of bits.  It
is followed by the bits coordinates, LSB first.  Here it’s an inner
block, so the coordinates are 2D.  Options are also 2D, and peripheral
blocks are 1D.</p>
<p>In such a case of symbolic mux it is followed by the indented possible
values of the mux (in hex) with the exclamation point indicating the
default.</p>
<p>A numeric mux is similar but the type is ‘n’ and labels on the right
have to be numeric.</p>
<p>Boolean muxes look like this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="n">clk0_inv</span>               <span class="n">b</span><span class="o">-</span>   <span class="mf">6.45</span>
</pre></div>
</div>
<p>The ‘b’ indicates boolean, and ‘-‘ indicates the default is false,
otherwise it is ‘+’ for true.  The boolean can be multi-bits, such as
in the following example.  Then all bits are set or unset.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="n">pr_en</span>              <span class="n">b</span><span class="o">-</span><span class="p">:</span><span class="mi">2</span> <span class="mf">0.61</span> <span class="mf">0.67</span>
</pre></div>
</div>
<p>Finally ram muxes look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="n">cvpcie_mode</span>                      <span class="n">r</span><span class="o">-</span><span class="p">:</span><span class="mi">2</span>    <span class="mf">2.21</span> <span class="mf">2.22</span>
<span class="n">g</span> <span class="n">clkin_0_src</span>                      <span class="n">r2</span><span class="p">:</span><span class="mi">4</span>  <span class="mi">760</span> <span class="mi">761</span> <span class="mi">762</span> <span class="mi">763</span>
</pre></div>
</div>
<p>In the second case the ‘2’ between r and : indicates that the default
value is 2.</p>
<p>Instanciated muxes can take two forms.  For instance in fpll muxes of
subtype ‘c’ are instanciated on the counter number, hence have 9
values.  The mux is written as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">c</span> <span class="n">cnt_in_src</span>                       <span class="n">r2</span><span class="p">:</span><span class="mi">2</span>  <span class="mi">600</span> <span class="mi">601</span> <span class="o">|</span> <span class="mi">602</span> <span class="mi">603</span> <span class="o">|</span> <span class="mi">604</span> <span class="mi">605</span> <span class="o">|</span> <span class="mi">606</span> <span class="mi">607</span> <span class="o">|</span> <span class="mi">608</span> <span class="mi">609</span> <span class="o">|</span> <span class="mi">610</span> <span class="mi">611</span> <span class="o">|</span> <span class="mi">612</span> <span class="mi">613</span> <span class="o">|</span> <span class="mi">614</span> <span class="mi">615</span> <span class="o">|</span> <span class="mi">616</span> <span class="mi">617</span>
<span class="n">c</span> <span class="n">dprio0_cnt_hi_div</span>                <span class="n">r1</span><span class="p">:</span><span class="mi">8</span>
  <span class="o">*</span> <span class="mi">8</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span> <span class="mi">13</span> <span class="mi">14</span> <span class="mi">15</span>
  <span class="o">*</span> <span class="mi">24</span> <span class="mi">25</span> <span class="mi">26</span> <span class="mi">27</span> <span class="mi">28</span> <span class="mi">29</span> <span class="mi">30</span> <span class="mi">31</span>
  <span class="o">*</span> <span class="mi">40</span> <span class="mi">41</span> <span class="mi">42</span> <span class="mi">43</span> <span class="mi">44</span> <span class="mi">45</span> <span class="mi">46</span> <span class="mi">47</span>
  <span class="o">*</span> <span class="mi">56</span> <span class="mi">57</span> <span class="mi">58</span> <span class="mi">59</span> <span class="mi">60</span> <span class="mi">61</span> <span class="mi">62</span> <span class="mi">63</span>
  <span class="o">*</span> <span class="mi">72</span> <span class="mi">73</span> <span class="mi">74</span> <span class="mi">75</span> <span class="mi">76</span> <span class="mi">77</span> <span class="mi">78</span> <span class="mi">79</span>
  <span class="o">*</span> <span class="mi">88</span> <span class="mi">89</span> <span class="mi">90</span> <span class="mi">91</span> <span class="mi">92</span> <span class="mi">93</span> <span class="mi">94</span> <span class="mi">95</span>
  <span class="o">*</span> <span class="mi">104</span> <span class="mi">105</span> <span class="mi">106</span> <span class="mi">107</span> <span class="mi">108</span> <span class="mi">109</span> <span class="mi">110</span> <span class="mi">111</span>
  <span class="o">*</span> <span class="mi">120</span> <span class="mi">121</span> <span class="mi">122</span> <span class="mi">123</span> <span class="mi">124</span> <span class="mi">125</span> <span class="mi">126</span> <span class="mi">127</span>
  <span class="o">*</span> <span class="mi">136</span> <span class="mi">137</span> <span class="mi">138</span> <span class="mi">139</span> <span class="mi">140</span> <span class="mi">141</span> <span class="mi">142</span> <span class="mi">143</span>
</pre></div>
</div>
<p>Either the bits are indicated on the same line separated by ‘|’, or
they’re set as one set per line start with an indented ‘*’.</p>
<p>The lab, mlab, m10k, mlab and hps_clocks target bits in the 2D cram by
offsetting from a base position computed from the tile position (see
the method pos2bit).  opt targets bits in the oram.  All the others
with the exception of pma3-c target bits in the pram from a position
found in &lt;die&gt;-pram.txt.  pma3-c targets bits in the cram from the
tables in pma3-cram.txt</p>
<p>mux_to_source.py enum &lt;datadir&gt; generates the file cv-bmuxtypes.ipp
while mux_to_source.py mux &lt;datadir&gt; generates the file
cv-bmux-data.cc.  mkmux.sh does both calls.</p>
</div>
<div class="section" id="logic-blocks">
<h3>Logic blocks<a class="headerlink" href="#logic-blocks" title="Permalink to this headline">¶</a></h3>
<p>Blocks come from two sources, the files &lt;die&gt;-pram.txt indicates all
the peripheral blocks with their pram address.  The files
&lt;die&gt;-&lt;block&gt;.txt where bock is cmux, ctrl, fpll, hmc, hps or iob has
the information of the connections between the blocks and neighbouring
blocks and the routing grid.</p>
<p>blocks_to_source.py generates the cvd-&lt;die&gt;-blk.cc file for a given
die, abd mkblocks.sh calls it for every die.</p>
</div>
<div class="section" id="inverters">
<h3>Inverters<a class="headerlink" href="#inverters" title="Permalink to this headline">¶</a></h3>
<p>The list of inverters, their cram position and their default value
(always 0 at this point) is in &lt;die&gt;-inv.txt.
inv_to_source.py/mkinv.sh takes care of generating the
cvd-&lt;die&gt;-inv.cc files.</p>
</div>
<div class="section" id="forced-1-bits">
<h3>Forced-1 bits<a class="headerlink" href="#forced-1-bits" title="Permalink to this headline">¶</a></h3>
<p>Five of the seven dies seem to have bits always set to 1.  They are
listed in the files &lt;die&gt;-1.txt.  blocks_to_source.py takes care of
it.</p>
</div>
<div class="section" id="packages">
<h3>Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h3>
<p>The file &lt;die&gt;-pkg.txt lists the packages and the pins of each package
for each die.  pkg_to_source.py/mkpkg.sh take cares of generating the
cvd-&lt;die&gt;-pkg.cc files.</p>
</div>
<div class="section" id="models">
<h3>Models<a class="headerlink" href="#models" title="Permalink to this headline">¶</a></h3>
<p>models.txt includes all the information on variants and models.  The
cv-models.cc file is generated by models_to_source.py called by
mkmodels.sh.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2020

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>